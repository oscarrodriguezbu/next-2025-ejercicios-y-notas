NEXT:

# ANTES DE EMPEZAR
- Todo el curso esta con react router
- Se usa versión 13 y 14 de Next
- Descargar imágenes de Docker en una terminal de comandos:
docker pull mongo:6.0.6
docker pull postgres:15.3
- Las imágenes se pueden eliminar luego en Docker desktop
- Versión Node 16 o superior


# seccion 2: INTRODUCCION A NEXT:
React Server Components
Client Components
TurboPack
Metadata
Metatags
Layouts y Layouts anidados
Poco de Tailwind
Next Link
usePathName Hook
Nuevo sistema de rutas de Next


## NOTAS:
- NEXT es un meta framework, un framework basado en un framework
- SEO friendly (SEARCH ENGINE OPTIMIZATION)
- Todo lo de React funciona en Next
- Menos dependencias, viene con herramientas dedicadas
- Recomendado para server-rendering
- Asume que el backend es Node y tiene muchas herramientas utiles
- Desde la version 13 de Next todo cambió
- En caso de ver un error ServerError: TypeError: .... Pueden dejar de usar turbopack al correr el ambiente desarrollo (deben eliminar la bandera --turbo en el package.json -> scripts -> dev) y todo debería funcionar tal como se espera. Turbopack aún se encuentra en beta por lo cual no es recomendado hacer uso del mismo en entornos de producción.
- Server components es que el cliente no va a recibir javascript a menos que no sea necesario
- En el layout o en cada una de nuestras paginas se puede configurar la metadata https://developers.google.com/search/docs/crawling-indexing/special-tags?hl=es
- Si la pagina no se le configura la metadata, se usa la del layout
- mr + tab es el snippet para la construir la base de la metadata
- Los layouts pueden ser anidados
- snippet lrc para crear un layout component
- Si nombro una carpeta con () es para decirle a Next que no queremos que ese nombre sea parte de la url de la pagina
- En la raiz del proyecto se puede crear una carpeta para componentes transversales
- Se puede precargar una pagina antes que el usuario cliquee
- Un console log no se muestra en el navegador, pero si en la terminal donde se pone a correr la aplicación
- Por defecto todos los componentes son asincronos
- Por lo general, todo sigue funcionando incluso si se deshabilita javascript
- Presentation Server componentes Strategy
- Si un componente no trabaja con server component, entonces toca encapsularlo. Se recomienda que todo sea server component
- Con Tailwind se le puede pasar varias clases a una clase con aply en el arhivo css
- usePathname para tomar la url de la pagina actual
- texto 'use client'; al inicio del archivo del componente es para generar algo por el lado del cliente, usualmente para cosas interactivas como botones
- 

--------------------------------------------------------------
# seccion 3  Despliegues a Vercel y Docker
Generar el build de producción / distribución
Probar el procedimiento de construcción y ejecución
Desplegar la aplicación en Vercel (Creado por la misma gente de Next.js)
Generar una imagen de Docker
Crear la imagen de Docker siguiendo las prácticas recomendadas por Next
Correr la aplicación desde Docker Desktop


## NOTAS:
- El build de produccion es mucho mas rapido que el de desarrollo
- Vercel creó Next y está optimizado para que los proyectos de Next se suban ahí
- Se despliega en una imagen de docker
- En la clase se propone dos formas de subir, una configuracion basica y sencilla y otra que es la recomendada por docker


--------------------------------------------------------------

# seccion 4 Server Side + Cliente Side Rendering
Puntualmente veremos:
Tailwind classes
Estructura de un dashboard
useState
use-client
Next Link
Next Image
Estructura de proyecto
Permitir imágenes externas
Entre otras cosas


## NOTAS:
- Componente para imagenes de Next es super recomendado. https://nextjs.org/docs/app/api-reference/components/image
- Para el curso, tener en cuenta que se debe usar react router con next para continuar con la configuracion desarrollada en la clase
- Ir a Next config para aceptar imagenes con urls externas
- Next image se encarga de optimizar las imagenes y se cargan bajo demanda
- Al hacer cambios de estado como hooks o al usar componentes de otras librerias, toca usar 'use client'; al inicio de ese archivo, pero se pierde los beneficios del server component
- Al ser 'use client'; se pierde la posibilidad de configuracion de la metadata, aunque se soluciona creando un componente hijo que tenga el 'use client'; y el padre quedaria con la function del server side


--------------------------------------------------------------

# seccion 5, Generación Dinamica SSR (SERVER SIDE RENDERING)
Manejo de Metadata dinámica
Páginas generadas del lado del servidor - SGR
Páginas de errores
Validación de argumentos
Redirecciones
Prioridad de Carga de imágenes
Tipos de revalidación con Fetch y sin Fetch
Estructuras HTML con Tailwind
Entre otras cosas


## NOTAS:
- Todo lo que se haga con fetch se guarda en caché
- El revalidate guarda en cache durante el tiempo que se le especifique, o si no se quiere cache, se lo coloca cache no store
- Mas info https://nextjs.org/docs/app/getting-started/fetching-data
- No se puede tener un a dentro de un Link
- priority={false} //es para el lazy load en un Image component
- Se crea la metada en la pagina de pokemon de dorma dinamica para que cargue el nombre del pokemon seleccionado en el tabulador
- Debug forma rapida en visual studio code. CTRL + SHFT + P, debug npm script, dev. Se puede hacer un escript y colocar por ejemplo un F5 para hacer todo eso
- Se crea un nuevo component not-found para evitar que en la url salga algun error y redireccione
- Hay una function notFound para redireccionar a la pagina de not found
- En tailwind toca especificar en su carpeta de configuracion las carpetas a las que se les quiere aplicar sus herramientas



--------------------------------------------------------------

# seccion 6 Incremental & Static Generation
Esta sección está dedicada principalmente a la generación estática de contenido, el objetivo principal de este mecanismo, es adelantarnos a las posibles solicitudes de nuestros usuarios y tener generadas de antemano las posibles páginas que ellos van a solicitar.

Es decir, en "build time" o tiempo de construcción, crearemos todas las páginas acorde a nuestras reglas, y luego le añadiremos condiciones de re-valicación para que se renueven cuando el momento lo amerite.


## NOTAS:
- Consiste en tener listas ciertas paginas antes de que el usuario entre en ellas
- Evitar colocar ids en la url, es mejor colocar nombres o identificador unico
- La sección del pokemon soporta por nombre y por id


--------------------------------------------------------------

# seccion 7 Global State - Redux y LocalStorage
Esta sección tiene por objetivo principal dos cosas:
Manejo de Favoritos
Trabajar LocalStorage con Server components
Esto llevará indiscutiblemente a inconvenientes, pero de antemano les digo, cuando trabajemos las aplicaciones reales con bases de datos y Cookies, no es necesario tanta complejidad que se debe de colocar para trabajar y construir aplicaciones que usen el local storage en Next y ese localstorage modifique lo que se genera en pantalla.

Pero sin embargo, esta sección tiene un alto valor educativo que es necesario comprender, porque es cuestión de tiempo para que choquemos con este problema.



## NOTAS:
- El provider de redux se usa en el layout principal en esta clase
- 'use client'; en el provider que se crea en la carpeta store
- El archivo del store se configura en el index de esa carpeta
- Hooks para usar en redux: useAppDispatch y useAppSelector
- Cada reducer tiene su state y su action en el param. Debe producir un nuevo estado basado en la accion
- En next se puede crear un restfull api. Por ejemplo en la carpata api se hace la configuracion y al final tenemos por ejemplo la url para hacer la peticion http://localhost:3000/api/counter
- En request.method viene metodos, cookies etc
- No colocar page y route en el mismo archivo
- Basicamente casi todo lo que se aplica en la parte de pages se aplica los routes
- El counter tiene un bug que primero se muestra un 5 y luego el 100, se puede seguir optimizando pero el profe Fernando va a explicar eso en otras clases mas adelante


--------------------------------------------------------------

# seccion 8 Estado Global - Favoritos
En esta sección trabajaremos con más elementos de Material UI y también crearemos nuestra propia implementación de un Drag and Drop (sin librerías de terceros)

El objetivo principal es tener el control de las entradas y poder jugar con ellas a nuestra voluntad.


## NOTAS:
- El local storage solo se manipula del lado del cliente
- Esta clase es solo demostrativa, en otras secciones se hace las configuraciones necesarias mucho mas facil y de otra forma
- No se recomienda guradar en local storage en el reducer
- Las cookies son persistentes como el localstorage, pero pueden enviarse por peticiones http
- Una de las formas recomendadas para guardar en localstorage es con middlewares
- Al final del ejercicio no se usa el middleware porque genera muchos problemas y se crea una propiedad favorites en el store para no mutar el state raiz



--------------------------------------------------------------

# seccion 9: Next Api Routes - Restfull handlers
Puntualmente veremos:
READ
Paginaciones
Update
Post
SEED
Docker
Postgres
Prisma
Prisma + Next
Yup - Validador


## NOTAS:
- Actualmente 2025 el tema del restfull api de next no es tan bueno como nest
- Se configura imagen de postgres en docker y en next con el archivo docker-compose.yml
- Se usó postgres:15.3
- Se levanta la base de datos en postgres en docker y luego se abre en un gestor de bases de datos como table plus
- Prisma sirve para ahorrarnos escribir querys para la database o algo asi
- Prisma es muy bueno pero no nos deja mucho control para la database, como triggers y cositas asi
- En el archivo schema.prisma se configuran los modelas de la base de datos
- Se crea una semilla con ayuda de prisma, eso consiste en generar data dummy para pruebas
- Se instala yup para validar los endpoints
- Prisma es como mongoose


--------------------------------------------------------------

# seccion 10 Next + RestAPI AdmintTodos
Consumo de nuestro RESTful Api
Client y Server Side Rendering
Refresh de una ruta sin afectar estados (nuevo de Next)
Prisma pull y push para actualizar modelos


## NOTAS:
- npx prisma db pull con prisma para traer toda la data y el modelo de la base de datos, luego npx prisma generate
- Si se hace algun cambio en la estructura del modelo en schema.prsma en next, luego npx prisma migrate dev, luego seleccionar si, escrbir el nombre de la migracion que es algo asi como un commit y la base de datos queda en sincronia con el schema 
- Si quiero hacer un cambio en el modelo pero sin los riesgos del  paso anterior, entonces coloca npx prisma db push y eso sincroniza la base de datos sin pasar con migraciones
- router.refresh(); Actualiza los componentes que son afectados:


--------------------------------------------------------------

# seccion 11 Server actions - optimistic updates - Next 14+
Esta tiene por objetivo usar características nuevas de Next y React como son:
Server Actions
useOptimistic
Server Actions marca un antes y después de comunicación cliente / servidor, ya que antes, ocupábamos una llamada HTTP mediante un restful API para realizar un cambio desde el cliente... ahora no es necesario.
La parte del hook de React useOptimistic, nos ayudará a que podamos realizar cambios en el UI aunque no tengamos las respuestas esperadas de procesos asíncronos.


## NOTAS:
- Actualizaciones optimistas permiten hacer cambios visuales cuando el servidor esta muy demorado
- Se instala nuevo paquete check updates. nc --update para subir las versiones del proyecto (pero actualmente no es necesario), luego npm i
- El server actions no necesita crear cosas adicionales, hace que todo parezca simples funciones de javascript
- server actions son como un patron
- Se crean en una carpeta llamada actions
- Para que algo se ejecute especificamente del lado del servidor colocar 'use server';
- revalidatePath('/dashboard/server-todos'); //? es para que cargue lo que cambió
- Hay dos formas de mutar data, hay un tema de mutacion que introduce next en la version 14 pero no es muy flexible actualmente
- los server actions en los eventos como el click, toca enviarlos de esta forma: () => deleteCompleted()
- useOptimistic hook de react: Es muy parecido al use state, recibe el estado inicial y un callback
  const [todoOptimistic, toggleOptimistic] = useOptimistic(
    todo,
    (state, newCompleteValue: boolean) => ({ ...state, complete: newCompleteValue })
  );
- sucede un warning pero se soluciona con un transition de react, exactamente el startTransition el cual es un callback que toca meterle lo que se quiere hacer la transicion
- dynamic y revalidate de next para hacer que la pagina cambie si la base de datos cambia. Carga cosas al pasar por la pantalla, como un useeefect o algo asi. Solo aplica para Pages, Layout o Rute Handler
- export const dynamic = 'force-dynamic'; se pega al inicio del archivo



--------------------------------------------------------------

# seccion 12 Cookies - Server y Client Side 
Cookies del lado del servidor
Cookies del lado del cliente
Carrito de compras
Manipulación de cookies


## NOTAS:
- Las cookies pueden tratarse del lado del servidor o del cliente
- Cualquier peticion http, viajan las cookies
- En Next, al trabajar con server components, se puede trabajar mas facil con las cookies
- Se usa paquete cookies-next del lado del cliente
- Se puede configurar las cookies como por ejemplo, expiracion etc
- Del lado del servidor se puede obtener las cookies con las herramientas de Next
- La comunicacion entre componentes no cercanos puede ser mediante las cookies, toda la seccion de productos y carrito de compras se hizo con cookies
- Mantener informacio NO sensible en las cookies


--------------------------------------------------------------
# seccion 13 Auth.js - Autenticacion de proteccion de rutas
Esta es una sección dedicada enteramente a la autenticación de los usuarios, trabajaremos con Auth.js para tener la base de autenticación inicial y luego la ajustaremos a necesidades personalizadas.

Puntualmente veremos:
Auth.js
Proveedores
Google
Github
Credenciales personalizadas
Encriptación de contraseña
Relaciones de base de datos
Sesión de usuario
Server y Client side validation
Campos adicionales de usuario
Modificación global de usuario de Auth.js
Mucho más
Es una sección que nos ayudará a poder controlar la sesión y a poder tener identificados los usuarios de nuestra aplicación y dashboard administrativo.



## NOTAS:
- Se usa Auth js para manejar la autenticacion, permite tener el control de la session del lado del cliente o servidor, algo asi como firebase. Auth se integra muy bien con Next
- Luego toca crear los endpoints respectivos en Next, algo asi src\app\api\auth\[...nextauth]\route.ts
- Toca ir a GitHub y google para configurar algunas cosillas para iniciar con esas paginas
- Se agrega un provider en RootLayout para trabajar con el hook de react de session
- Los usuarios modifican los todos sin afectar los datos de otros usuarios


--------------------------------------------------------------
# seccion 14 E-Commerce - Diseño TesloShop
En esta sección empezaremos a trabajar en la maquetación de nuestra aplicación de e-commerce "TesloShop"
Aquí aprenderemos sobre:
Server Components
Client Components
Zustand
Tailwind
CLSX
Estructura de directorios
Layouts anidados
Componentes reutilizables
Efectos de Blur con Tailwind
Efectos con las imágenes de productos
Rutas de nuestra aplicación
Y mucho más.


## NOTAS:
- import { inter } from "@/config/fonts"; en el layout principal para configurar las fuentes
- cuando en una carpeta de un layout no quiere que tenga un nombre en la ruta propio, se le coloca parentesis como: (shop)
- Carpeta que requieren un valor dinamico como id, se les nombra [id]
- un slug es un identificador humanamente legible, algo asi como lo que usa amazon en sus productos
- onMouseEnter y onMouseLeave para cambiar las imagenes de la tienda
- Se crea un store con zustand para manipular el sidebar
- se instala clsx que permite hacer clases condicionales con tailwind


--------------------------------------------------------------
# seccion 15 E - Commerce Diseño parte 2
Puntualmente veremos:
Tailwind
Multiples layouts
Pantallas de error
Slideshows
Slideshows para teléfonos
Navegación
Redirecciones
Tablas
Etc


## NOTAS:
- Se instala swiper para trabajar como carrusel con las imagenes
- Se crea un carrusel para escritorio y otro para movil para no tener tantas condiciones, la validacion se hace con las clases responsivas de tailwind


--------------------------------------------------------------
# seccion 16 Preparacion de based 
En esta sección prepararemos la base de datos y un procedimiento "seed" para llenar la misma con información de desarrollo.
Puntualmente veremos:
Docker PostgreSQL
Docker Compose
Idea de una semilla (seed)
Crear enumeraciones de base de datos
Tabla de
Productos
Categorías
Imagenes de productos
Procedimiento independiente dentro del proyecto de Next


## NOTAS:
- Por si acaso alternativa  docker para postgres https://neon.com/ pero el curso usa docker
- EL REDUCE EN UN ARRAY ES COMO UN FOREACH PERO PERMITE IR ACUMULANDO LOS CAMBIOS


--------------------------------------------------------------
# seccion 17 Paginacion del lado del servidor
Esta sección es muy importante para comprender el ¿por qué? de la paginación del lado del servidor, pero puntualmente veremos:
Obtener data del servidor
Paginar resultados
Añadir condiciones
Re-utilización de componentes
Paginación del lado del servidor
Manejo de SearchParams

La idea es que podamos compartir un URL de nuestra tienda virtual que apunte a una página en particular y podamos reconstruir exactamente el mismo resultado.



## NOTAS:
- const totalPages = Math.ceil(totalCount / take); //ceil es para ir al siguiente numero entero si hay un decumal. 4.1 seria 5
- export const revalidate = 60; // 60 segundos //? Hace que si la data cambia en la bd, en 60 segundos vuelve y hace la peticion para trear data actualizada
- Al hacer npm run build, aparecen unas sugerencias, hay que cliquear cada una y hacer las modificaciones recomendadas. NO DESACTIVAR EL LINTER


--------------------------------------------------------------
# seccion 18 Pantalla de producto
En esta sección estaremos trabajando con la pantalla de producto, puntualmente veremos:
Traer información del producto
Revalidación de data cada 7 días
Renderizar del lado del cliente únicamente la información que cambia constantemente
Server Actions
Información OpenGraph
Cambiar Metadata
Detalles a la hora de compartir enlaces en redes sociales
Aquí recorreremos la milla extra para poder hacer una pantalla que a la hora de compartirla en redes sociales se vea y se sienta profesional y a la vez, ayudar al SEO.



## NOTAS:
- Al SEO le gusta los identificadores en las url con mas claridad, con guiones bajos y que describan algo
- En src\app\(shop)\product\[slug]\page.tsx esta lo de la metadata dinamica con generateMetadata
- https://www.opengraph.xyz/ es para probar como se ve la aplicacion al compartir en redes sociales, no se puede mandar el link con localhost
- https://ngrok.com/ toca instalarlo y registrarse, ayuda a exponer la ip publica en la url y se pega en opengraph y listo


--------------------------------------------------------------
# seccion 19 Carrito de compras
En esta sección vamos a trabajar construyendo y manteniendo el carrito de compras del usuario. Aún para este punto no necesitamos credenciales porque lo podemos grabar en cookies, session storage o local storage.
Puntualmente veremos:
Zustand con NextJS App Directory
Problemas de hidratación
Manejo de estado del lado del cliente
Manejo del carrito de compras
Remover y cambiar cantidad desde la pantalla del carrito de compras
Formato de moneda sin dependencias


## NOTAS:
- const [loaded, setLoaded] = useState(false);
  useEffect(() => {
    setLoaded(true);// es para asegurarse de que todo se haya renderizado y lo que construye el servidor haga match con lo del cliente
    //y se soluciona el error de hidratacion que genera la manipulacion de la data en el local storage
  }, [])
- La hidratacion se refiere a algun cambio en la pantalla que tiene relacion con data almacenada localmente
- Formato de moneda solo con javascript:
export const currencyFormat = (value: number) => {

  return new Intl.NumberFormat("en-US", { //Intl viene javascript
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(value);
  
};


--------------------------------------------------------------
# seccion 20 NextAuth
Esta sección está dedicada a la autenticación que haremos a nuestra aplicación.
Puntualmente veremos:
Next Auth
Custom Login
Custom SignUp
Dos aproximaciones para manejo de server actions
	Desde Form Actions
	Desde funciones
Varios hooks propios de React Dom
Estado de formularios sin JavaScript
Validaciones de formularios
React Hook Form
Sesiones
Extensión de sesiones
Protección de rutas
Seed de usuarios
Encriptación de contraseñas
Validación de usuarios



## NOTAS:
- Se maneja validacioes del lado del servidor y del cliente en login y registro, ambas forma son validas. Del lado del servidor es mas compleja
- Se instala next auth, en el curso se usa una version experimental porque no habia otra manera
- Se agrega nueva variable de entorno para hacer funcionar el auth next
- Se configura el archivo src\auth.config.ts
- Se instala zod para crear un schema de validacion
- Se usa el hook   const [state, dispatch] = useFormState(authenticate, undefined);
- Se crea el modelo User en schema.prisma
- La ruta src\app\api\auth\[...nextauth]\route.ts la parte ...nextauth es un comodin que indica que cualquier endpoint que pase va a caer en ese endpoint
- Se utiliza https://react-hook-form.com/ para el login


--------------------------------------------------------------
# seccion 21 Direccion de Entrega
En esta sección nos enfocaremos en trabajar con la dirección de entrega de la orden, y aunque se puede resumir simplemente a almacenar la dirección en el localstorage, quiero que vayamos más allá.
Puntualmente veremos:
Zustand Address Store
Persistencia
Almacenar en base de datos la dirección del usuario
Relaciones uno a uno
Relaciones uno a muchos
Server Actions para:
Guardar dirección
Actualizar la dirección
Borrar la dirección
React Hook Form
Conectar Zustand con UseForm con Base de datos


## NOTAS:
- npx prisma studio para explorar la base de datos sin otro programa como table plus por ejemplo


--------------------------------------------------------------
# seccion 22 Creacion de Ordenes
En esta sección vamos a trabajar creando las ordenes de compra de los clientes. Puntualmente veremos:
Relaciones uno a uno
Relaciones de uno a muchos
Transacciones de base de datos
Transacciones con Prisma
Manejo de inventario
Crear ordenes
Maestro - Detalle
Server actions
Consideraciones a la hora de crear la orden basado en un carrito de compras

Es una sección técnicamente intermedia, ya que debemos de considerar muchos factores para crear una orden, y todo debe de salir bien a la hora de guardar en la base de datos y si algo falla, debemos de hacer un rollback de todo, aquí es donde las transacciones nos ayudarán.


## NOTAS:
- Se va a hacer rollback si algo sale mal con la orden
- Se valida la cantidad del stock al momento de comprar y si dos personas compran a la vez, la compra se hace con la primer persona que lo haga
- Los totales se hacen del lado del servidor para que el usuario no altere la data
- En lugar de trabajar con prisma se usa tx para guardar en memoria antes de guardar, si no sale bien entonces se hace un rollback en src\actions\order\place-order.ts
- Tener en cuenta que al aplicacion no considera el stock por tallas sino por el producto en si
- Queda pendiente mas validaciones


--------------------------------------------------------------
# seccion 23 Pagos PayPal
El objetivo de esta sección es simple, realizar los cobros mediante un servicio de terceros, en este caso, Paypal.
Puntualmente veremos:
Generar el intento de pago
Realizar el Cobro en PayPal
Validar el pago desde el lado de PayPal
Registrar el pago y la fecha de pago
Marcar la orden como pagada
Configuraciones en el Sandbox de PayPal

Ahora, muchas personas han pedido otras plataformas de cobros aparte de PayPal, pero en sí, el proceso es similar a lo que verán aquí, también muchos servicios ofrecen webhooks (se ve de este tema en el curso de Node) el cual notifica el pago a un servicio, lo cual es útil en el caso de que la conexión sea interrumpida por el lado del cliente.

Pero de igual manera, cada vez que revisemos la orden, confirmaremos si el pago se ha realizado de nuestro lado.


## NOTAS:
- Herramienta para integrar paypal con react de forma oficial: https://www.npmjs.com/package/@paypal/react-paypal-js
- A paypal no hay que mandarle mas de dos decimales


--------------------------------------------------------------
# seccion 24 Mantenimientos Administrativos
En esta sección nos enfocaremos en los mantenimientos administrativos de:
Usuarios:
Cambiar Roles

Ordenes:
Ver todas las ordenes realizadas de todos los usuarios

Productos:
Creación
Edición
Carga de archivos mediante server actions

La idea es que nos enfoquemos fuertemente en la parte de la creación y mantenimiento de productos para poder crear y actualizar su información


## NOTAS:
- El panel administrativo ve las ordenes de toda la aplicación, pero solo lo ve el administrador
- Se usa cloudinary para almacenar las imagenes. No se usa la carpeta publica del proyecto porque se recomienda que las imagenes se guarden en un lugar especializado ademas porque la carpeta publica puede ser muy volatil y se puede borrar por accidente cosas


--------------------------------------------------------------
# seccion 25 Desplegar tienda
Esta es una sección corta, pero el objetivo es desplegar y probar nuestro sitio web en producción, para esto ocuparemos aprovisionar una base de datos PostgreSQL para poder ejecutar el proceso de migración y construcción.
Puntualmente veremos:
Pruebas locales
Solución de warnings y errores
Aprovisionar una base de datos PostgreSQL
Desplegar.
Probar OpenGraph data


--------------------------------------------------------------